"""
This script utilises the data generated by evolution.py to plot
graphs similar to fig 3 in the PNAS paper.

Issues: this script is still a bit rough, with lots of debugging
features intact and the plotting section all jumbled up. Cleanup 
needed (eventually).

The ONI data comes from https://psl.noaa.gov/enso/data.html
under 'Time Series' instead of being calculated from the raw
temperature measurements themselves. This is likely slightly
different from how the plot is produced in the PNAS paper.
"""

import numpy as np  # no CUDA required for this script
import matplotlib.pyplot as plt
from matplotlib import gridspec

def process_oni(raw_file_name):
       """
       Process ONI data - return processed array to plot.
       """
       # read into data matrix and drop year column
       data_matrix = np.loadtxt(raw_file_name, usecols = range(13))
       data_matrix = np.delete(data_matrix, 0, 1)
       print('Dimension of raw ONI data array: ', 
              np.shape(data_matrix))
       
       # adjust to years starting with July 1st & consistent 
       # with later parts
       data_matrix = np.roll(data_matrix, -6)
       data_matrix = np.concatenate((np.zeros([1, 12]), 
                                     data_matrix), axis=0)
       data_matrix = np.delete(data_matrix, -1, 0)

       return data_matrix
       
       
def moving_average(x, w):
       """
       Returns a w-moving average array (edges not included).
       """
       return np.convolve(x, np.ones(w), 'valid') / w

# load data 
with open('bulk_temp_1949_2016.npy', 'rb') as f:
    results = np.load(f)
    lat = np.load(f)
    lon = np.load(f)

# select the relevant interval and discarding the rest
results = results[1949:2017, :, :, :]
print('Shape of distilled results: ', np.shape(results))

"""
This next section does not impact the final plot, it
merely keeps track of the arrays as they are processed
to be plotted later, since the dimensions can be
difficult to wrangle with after a few steps.

See the relevant section in the PNAS paper for a
more detailed explanation on N_y and C_y.
"""
n_y = np.count_nonzero(results[:, :, 1, :], axis = 2)
print('Shape of N_y array: ', np.shape(n_y))
n_y_flat = n_y.flatten()
print('Shape of flattened N_y array: ', np.shape(n_y_flat))
n_y_moving_average = moving_average(n_y_flat, 3)
print('Shape of moving average (3-month) N_y array: ', 
       np.shape(n_y_moving_average))
# make up for lost edge points by concatenating original vals
n_y_moving_average_adjusted = np.concatenate((n_y_flat[0:2], 
                                              n_y_moving_average))
print('Shape of adjusted moving average N_y array: ',
       np.shape(n_y_moving_average_adjusted))

c_theta = np.sum(abs(results[:, :, 0, :]), axis = 2)
print('Shape of C_theta array: ', np.shape(c_theta))
c_y = c_theta / n_y
print('Shape of C_y array: ', np.shape(c_y))
c_y_flat = c_y.flatten()
print('Shape of flattened C_y array: ', np.shape(c_y_flat))
c_y_moving_average = moving_average(c_y_flat, 3)
print('Shape of moving average (3-month) C_y array: ',
       np.shape(c_y_moving_average))
c_y_moving_average_adjusted = np.concatenate((c_y_flat[0:2],
                                              c_y_moving_average))
print('Shape of adjusted moving average C_y array: ',
       np.shape(c_y_moving_average_adjusted))

# since the adjusted data arrays are flattened they need a fixed x-axis
year_labels = np.empty([68, 12])
years = np.arange(1949, 2017)  # years relevant
for i in range(12):
    year_labels[:, i] = years + i/12  # 12 months under each year
year_labels = year_labels.flatten()  # final array to use as x-axis

# process ONI data to plot
raw_file_name = 'noaa_oni_raw_data.txt'
oni_data = process_oni(raw_file_name)
oni_data_flat = oni_data.flatten()
print('Shape of flattened ONI data array: ', np.shape(oni_data_flat))

# begin plotting
fig = plt.figure()
gs = gridspec.GridSpec(3, 1, height_ratios=[1, 1, 1]) # set subplots

# ONI subplot
ax0 = plt.subplot(gs[0])
ax0.set_ylabel('$ONI$', fontsize = 16)
plot0, = ax0.plot(year_labels, oni_data_flat, c = 'darkgreen')
ax0.axhline(y = 1, c = 'red', linestyle = 'dotted')
ax0.axhline(y = -1, c = 'blue', linestyle = 'dotted')

# with ax0 (ONI) plotted we adjust the x-axis
plt.xticks(np.arange(1950, 2016, 1))  # set ticks to one per year only
plt.xlim([1950, 2015])  # only plot 1950-2015 ('results' covers it)

# N_y subplot
ax1 = plt.subplot(gs[1], sharex = ax0)
ax1.set_ylabel('$N^y$', fontsize = 16)
plot1, = ax1.plot(year_labels, n_y_moving_average_adjusted,
                  c = 'purple')

# C_y subplot
ax2 = plt.subplot(gs[2], sharex = ax0)  # shared x-axis
ax2.set_ylabel('$C^y$', fontsize = 16)
plot2, = ax2.plot(year_labels, c_y_moving_average_adjusted,
                  c = 'navy')

# plot top and bottom with shared x-axis
plt.setp(ax0.get_xticklabels(), visible=False)
plt.setp(ax1.get_xticklabels(), visible=False)
plt.subplots_adjust(hspace=.0)

# set x-axis (misc)
ax2.set_xlabel('Year', fontsize = 16)
plt.xticks(rotation = 45)  # rotate year labels
ax0.xaxis.grid(True)
ax1.xaxis.grid(True)
ax2.xaxis.grid(True)
n = 5  # Keeps every 5th year label
[l.set_visible(False) for (i,l) in 
 enumerate(ax2.xaxis.get_ticklabels()) if i % n != 0]

# set y-axis (misc)
yticks = ax2.yaxis.get_major_ticks()
yticks[-1].label1.set_visible(False)
fig.align_ylabels([ax0, ax1, ax2])

# placeholder for plotting tiles
#ax1.axvspan(1971.8, 1972.2, alpha=0.5, color='red')
#ax2.axvspan(1971.8, 1972.2, alpha=0.5, color='red')

# adjust final size and save to png
fig.set_size_inches(16, 6)
fig.savefig('test2png.png', dpi=60)

# draw on separate window upon running the script
plt.show()
